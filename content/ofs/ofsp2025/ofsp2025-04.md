---
uid: 20250826161556
title: ofsp2025-04
date: 2025-08-26
update: 2025-08-27
authors:
  - name: Aerosand
    link: https://github.com/aerosand
    image: https://github.com/aerosand.png
tags:
  - ofsp2025
  - OpenFOAM
  - test
excludeSearch: false
toc: true
weight: 4
math: true
next:
prev:
comments: true
sidebar:
  exclude: false
draft: false
---

> å‚è€ƒï¼š
> - https://github.com/UnnamedMoose/BasicOpenFOAMProgrammingTutorials
> - https://www.topcfd.cn/simulation/solve/openfoam/openfoam-program/
> - https://www.tfd.chalmers.se/~hani/kurser/OS_CFD/
> - https://github.com/ParticulateFlow/OSCCAR-doc/blob/master/openFoamUserManual_PFM.pdf
> - https://www.youtube.com/watch?v=KB9HhggUi_E&ab_channel=UCLOpenFOAMWorkshop
> - http://dyfluid.com/#
> - https://ss1.xrea.com/penguinitis.g1.xrea.com/study/OpenFOAM/index.html
> 
> æ„Ÿè°¢åŸä½œè€…ä»¬çš„æ— ç§å¼•è·¯å’Œå®è´µå·¥ä½œã€‚


> å‰ç½®ï¼š
> [OpenFOAMå¼€å‘ç¼–ç¨‹åŸºç¡€03 æ—¶é—´ç±»åˆæ­¥ | ğ“ğ“®ğ“»ğ“¸ğ“¼ğ“ªğ“·ğ“­ (aerosand.cn)](https://aerosand.cc/ofs/ofsp2025/ofsp2025-03)

å»ºç«‹æœ¬æ–‡çš„é¡¹ç›®æ–‡ä»¶å¤¹å¹¶è¿›å…¥

```
// terminal 
cd /home/aerosand/aerosand/ofsp
mkdir 04_mesh
cd 04_mesh
```

## ç½‘æ ¼ç±»æ–¹æ³•

### åº”ç”¨å‡†å¤‡

```
// terminal
foamNewApp 04_01_mesh
cd 04_01_mesh
cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity/cavity debug_case
code .
```

### è„šæœ¬å’Œè¯´æ˜

ä½¿ç”¨ä¸Šä¸€ç¯‡è®¨è®ºç›¸åŒè„šæœ¬å†…å®¹å³å¯ï¼Œç•¥

### mesh æ˜¯ä»€ä¹ˆ

æˆ‘ä»¬å…ˆä¸çœ‹ `createMesh.H` çš„æºä»£ç ï¼Œå…ˆä»åº”ç”¨çš„éœ€æ±‚åˆ‡å…¥ï¼Œä¹Ÿå°±æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦åŸºäºå…·ä½“çš„ case å»ºç«‹çš„è®¡ç®—ç”¨çš„ `mesh` ï¼Œè¿™ä¸ª `mesh` å½“ç„¶ä¹Ÿæœ‰è‡ªå·±çš„æ•°æ®ï¼ˆåŒ…æ‹¬ `point`, `face` ç­‰ç­‰ï¼‰ï¼Œä¹Ÿè¦æœ‰è‡ªå·±çš„æ–¹æ³•ï¼ˆåŒ…æ‹¬è¿”å›ç‚¹åˆ—ï¼Œè¿”å›é¢å¿ƒç­‰ç­‰ï¼‰ã€‚

#### primitiveMesh

OpenFOAM æä¾›çº¯ç²¹åŸºäºå‡ ä½•å…ƒç´ æ„é€ çš„ `primitiveMesh` ç±»ã€‚

é€šè¿‡ `Doxygen` æŸ¥æ‰¾å¯ä»¥çœ‹åˆ° `primitiveMesh` ä¸ç»§æ‰¿è‡ªä»»ä½•å…¶ä»–ç±»ï¼Œå®ƒå°±æ˜¯æœ€åŸºç¡€çš„åŸºç±»ã€‚

```
// termianl
find $FOAM_SRC -iname primitiveMesh.H
// /usr/lib/openfoam/openfoam2306/src/OpenFOAM/meshed/primitiveMesh/primitiveMesh.H
```

æ‰¾åˆ° `primitiveMesh.H` å¹¶æ‰“å¼€ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹å®ƒæä¾›çš„æ„é€ æ–¹æ³•

```cpp
...
class primitiveMesh
{
	...
protected:
	...
public:
	...
	//- Construct from components
	primitiveMesh
	(
		const label nPoints,
		const label nInternalFaces,
		const label nFaces,
		const label nCells	
	);
	...
...
```

å¯ä»¥çœ‹åˆ° `primitiveMesh` ç±»ä»åŸºæœ¬çš„ç‚¹ã€é¢ã€å•å…ƒæ„é€ å¯¹è±¡ã€‚

ç‚¹ã€é¢ã€å•å…ƒç”± `blockMesh` ç”Ÿæˆï¼Œæˆ–è€…ç”±ç¬¬ä¸‰æ–¹ç½‘æ ¼è½¯ä»¶ç”Ÿæˆå†è½¬æ¢æˆ OpenFOAM æ ¼å¼ã€‚æ— è®ºå¦‚ä½•ï¼Œç‚¹ã€é¢ã€å•å…ƒè¢«ç”Ÿæˆåœ¨ `case/constant/polyMesh/` æ–‡ä»¶å¤¹ä¸‹ã€‚æ³¨æ„ï¼Œè¿™é‡Œçš„å‡ ä½•æ•°æ®åªæ˜¯æ•°æ®è€Œå·²ï¼Œä¸å…·å¤‡ä»»ä½•çš„æ–¹æ³•ã€‚

æˆ‘ä»¬éœ€è¦å°†è¿™äº›ç¦»æ•£æ•°æ®å°è£…åˆ°ä¿¡æ¯æµä¸­ï¼Œä»¥æ–¹ä¾¿åç»­ä½¿ç”¨ã€‚

OpenFOAM æä¾› `IOobject` ç±»æ¥å°è£…æ¥å…¥è¿™äº›æ•°æ®ã€‚

```
// terminal 
find $FOAM_SRC -iname IOobject.H
// /usr/lib/openfoam/openfoam2306/src/OpenFOAM/db/IOobject/IOobject.H
```

æ‘˜å– `IOobject.H` ä¸­çš„ä¸€éƒ¨åˆ†å¦‚ä¸‹

```cpp
...
class IOobject
:
	public IOobjectOption
{
public:
	...
private:
	...
protected:
	...
public:
	...
	inline IOobject
	(
		const word& name, // åŸºäºçš„å¯¹è±¡åç§°
		const fileName& instance, // åŸºäºçš„å¯¹è±¡æ–‡ä»¶åç§°
		const objectRegistry& registry, // æ³¨å†Œç›¸å…³ï¼Œæš‚æ—¶æ— éœ€äº†è§£
		IOobjectOption::readOption rOpt, // è¯»å–é€‰é¡¹
		IOobjectOption::writeOption wOpt = IOobjectOption::NO_WRITE, // å†™å…¥é€‰é¡¹
		bool registerObject = true, // æœ‰é»˜è®¤å€¼ï¼Œå¯å¿½ç•¥
		bool globalObject = false // æœ‰é»˜è®¤å€¼ï¼Œå¯å¿½ç•¥
		// æš‚æ—¶äº†è§£ç”¨æ³•å³å¯
	);
	...
...
```

#### polyMesh

åœ¨ `primitiveMesh` ç±»çš„åŸºç¡€ä¸Šï¼ŒOpenFOAM åˆæä¾›æ´¾ç”Ÿçš„ `polyMesh` ç±»ã€‚`polyMesh` ç±»åŸºæœ¬ä¸Šè¿˜æ˜¯å‡ ä½•æ‹“æ‰‘çš„ï¼Œå…·æœ‰ä¸€äº›å‡ ä½•æ‹“æ‰‘çš„æ–¹æ³•ã€‚

```
// terminal
find $FOAM_SRC -iname polyMesh.H
```

æ‘˜å– `polyMesh.H` çš„ä¸€éƒ¨åˆ†å¦‚ä¸‹

```cpp
...
class polyMesh
: 
	public objectRegistry,
	public primitiveMesh
{
public:
	...
private:
	...
public:
	...
	//- Read construct from IOobject
	explicit polyMesh(const IOobject& io, const bool doInt = true);
	// explicit å…³é”®è¯ç¦ç”¨äº†éšå¼è½¬æ¢ï¼Œé¿å…å‘ç”Ÿæ„å¤–çš„ç±»å‹è½¬æ¢
	...
...
```

ä½¿ç”¨ `polyMesh` ç±»ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€  `mesh` å¯¹è±¡ï¼Œå¹¶è¿›è¡Œä¸€äº›ç½‘æ ¼æ“ä½œ

ä¾‹å¦‚ `04_01_mesh.C` ä¸­å†™å…¥

```cpp
#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"

    Foam::word regionName(Foam::polyMesh::defaultRegion);

    Foam::polyMesh mesh
    (
        IOobject
        (
            // fvMesh::defaultRegion,
            // å¯ä»¥ç›´æ¥ä½¿ç”¨defaultRegionï¼Œä¹Ÿå¯ä»¥æ–°å»ºä¸€ä¸ªregionName
            regionName,
            runTime.timeName(),
            runTime,
            IOobject::MUST_READ
        )
    );

    Info<< "Max cell centre: " << max(mesh.cellCentres()) << endl;
    Info<< "Max cell volumes: " << max(mesh.cellVolumes()) << endl;
    Info<< "Max cell face cetres: " << max(mesh.faceCentres()) << endl;
	// ä¸ºäº†å‡å°‘è¾“å‡ºï¼Œæ¯ä¸ªéƒ½å¥—äº†ä¸€ä¸ª max å‡½æ•°

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    Info<< nl;
    runTime.printExecutionTime(Info);

    Info<< "End\n" << endl;

    return 0;
}


// ************************************************************************* //

```

> æœ‰è¯»è€…å¯èƒ½ä¼šç–‘é—® `mesh` çš„æ„é€ ä¸ºä»€ä¹ˆåŸºäº `time` æ–‡ä»¶å¤¹è€Œä¸æ˜¯ `polyMesh` å­æ–‡ä»¶å¤¹ï¼Œæ¯•ç«Ÿç½‘æ ¼çš„å‡ ä½•ä¿¡æ¯å¹¶ä¸åœ¨ `time` æ–‡ä»¶å¤¹ä¸‹ï¼ˆå…¶å® `time` ç±»çš„ç›¸å…³å®šä¹‰æœ‰å‘åæœå¯»ï¼Œæ˜¯åŒ…æ‹¬ `mesh` ä¿¡æ¯çš„ï¼‰ã€‚è¿™é‡Œæ¶‰åŠåˆ°ç±»çš„å®ç°æºä»£ç ï¼Œä¸ç”¨æ·±ç©¶ä¹Ÿä¸å»ºè®®æ·±ç©¶ã€‚

ç¼–è¯‘è¿è¡Œï¼Œç»“æœå¦‚ä¸‹

```
Create time

Max cell centre: (0.0975 0.0975 0.005)
Max cell volumes: 2.5e-07
Max cell face cetres: (0.1 0.1 0.01)

ExecutionTime = 0 s  ClockTime = 0 s

End

```

#### fvMesh

OpenFOAM åœ¨ `polyMesh` ç±»çš„åŸºç¡€ä¸Šï¼Œæ·»åŠ äº†æœ‰é™ä½“ç§¯çš„æ–¹æ³•ï¼Œè¿›è€Œæ´¾ç”Ÿå‡ºäº† `fvMesh` ç±»ã€‚

```
// terminal
find $FOAM_SRC -iname fvMesh.H
```

çœ‹ä¸€ä¸‹ `fvMesh.H` ä¸­çš„ä»£ç ç‰‡æ®µ

```cpp
...
class fvMesh
:
    public polyMesh,
    public lduMesh,
    public fvSchemes,
    public surfaceInterpolation,    // needs input from fvSchemes
    public fvSolution,
    public data
{
protected:
	...
public:
	...
	explicit fvMesh(const IOobject& io, const bool doInit=true);
	...
...
```

ä½¿ç”¨ `fvMesh` ç±»ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€  `mesh` å¯¹è±¡ï¼Œå¹¶è¿›è¡Œä¸€äº›æ“ä½œï¼ŒåŒ…æ‹¬ç½‘æ ¼çš„æ“ä½œã€‚

ä¾‹å¦‚ `04_01_mesh.C` ä¸­é‡æ–°å†™å…¥

```cpp
#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"

    Foam::word regionName(Foam::polyMesh::defaultRegion);

    Foam::fvMesh mesh
    (
        IOobject
        (
            regionName,
            runTime.timeName(),
            runTime,
            IOobject::MUST_READ
        )
    );

    Info<< "Max cell centre: " << max(mesh.C()) << endl;
    Info<< "Max cell volumes: " << max(mesh.V()) << endl;
    Info<< "Max cell face cetres: " << max(mesh.Cf()) << endl;


    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    Info<< nl;
    runTime.printExecutionTime(Info);

    Info<< "End\n" << endl;

    return 0;
}
```

ç¼–è¯‘è¿è¡Œï¼Œç»“æœå¦‚ä¸‹

```
Create time

Max cell centre: max(C) [0 1 0 0 0 0 0] (0.1 0.1 0.005)
Max cell volumes: max(V) [0 3 0 0 0 0 0] 2.5e-07
Max cell face cetres: max(Cf) [0 1 0 0 0 0 0] (0.1 0.1 0.005)

ExecutionTime = 0 s  ClockTime = 0 s

End


```

è¯»è€…å¯ä»¥æŠŠ `max` å‡½æ•°å»æ‰é‡æ–°ç¼–è¯‘æŸ¥çœ‹ç»“æœã€‚åŸºäºè¿™ä¸‰ä¸ªå­ç±»å’Œçˆ¶ç±»çš„è®¨è®ºï¼Œæˆ‘ä»¬å¯ä»¥æƒ³è§ `createMesh.H` ä¸»è¦æ˜¯ä»€ä¹ˆä»£ç è¯­å¥ã€‚

### createMesh.H

çœ‹ä¸€ä¸‹å’Œç½‘æ ¼ç›¸å…³çš„å¤´æ–‡ä»¶ `createMesh.H`

```
// termianl
find $FOAM_SRC -iname createMesh.H
// /usr/lib/openfoam/openfoam2306/src/OpenFOAM/include/createMesh.H
```

ä»£ç çš„ä¸»è¦å†…å®¹ç®€è¦æ‘˜æŠ„å¦‚ä¸‹

```cpp
Info<< "Default region: " << fvMesh::defaultRegion << endl;
Info<< "Mesh sudirectory: " << fvMesh::meshSubDir << endl;
// OpenFOAM é¢„è®¾äº†é»˜è®¤çš„åŸŸå’Œç½‘æ ¼å­è·¯å¾„

Foam::autoPtr<Foam::fvMesh> meshPtr(nullptr);
// æ–°å»ºæŒ‡å‘ç½‘æ ¼å¯¹è±¡çš„æŒ‡é’ˆï¼Œåˆå§‹åŒ–ä¸ºç©ºæŒ‡é’ˆ
Foam::word regionName(Foam::polyMesh::defaultRegion);
// æ–°å»ºåŒºåŸŸåç§°ï¼Œåˆå§‹åŒ–é»˜è®¤åŸŸ

Foam::Info << "Create mesh";
Foam::Info << " for time = " << runTime.timeName() << Foam::nl;

meshPtr.reset // é€šè¿‡meshPtrçš„resetæ–¹æ³•é‡è®¾æŒ‡é’ˆæŒ‡å‘
(
	new Foam::fvMesh // åŸºäºå‚æ•°æ„é€ fvMeshç±»çš„æŒ‡é’ˆ
	(
		Foam::IOobject
		(
			regionName,
			runTime.timeName(),
			runTime,
			Foam::IOobject::MUST_READ
		),
		false
	)
);
meshPtr().init(true);

Foam::fvMesh& mesh = meshPtr();

Foam::Info << Foam::endl;

```

å¦‚æœä¸ä½¿ç”¨æŒ‡é’ˆï¼Œä¹Ÿå¯ä»¥åƒå‰æ–‡ä¸€æ ·ä½¿ç”¨ `fvMesh` ç›´æ¥åˆ›å»º `mesh` ã€‚

### ä¸»æºç 

ä¸»æºç æ­£å¼å†…å®¹å¦‚ä¸‹

```cpp
#include "fvCFD.H"

#include "IOmanip.H" // è¾“å‡ºæ ¼å¼æ§åˆ¶

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"

    /*
    * About createMesh.H
    */
    // #include "createMesh.H"
    // å±•å¼€ createMesh.H çš„ä¸»è¦å†…å®¹
    Info<< "Default region: " << fvMesh::defaultRegion << endl;
    Info<< "Mesh sudirectory: " << fvMesh::meshSubDir << endl;
    
    Foam::autoPtr<Foam::fvMesh> meshPtr(nullptr);
    Foam::word regionName(Foam::polyMesh::defaultRegion);

    Foam::Info << "Create mesh";
    Foam::Info << " for time = " << runTime.timeName() << Foam::nl;

    meshPtr.reset
    (
        new Foam::fvMesh
        (
            Foam::IOobject
            (
                regionName,
                runTime.timeName(),
                runTime,
                Foam::IOobject::MUST_READ
            ),
            false
        )
    );
    meshPtr().init(true);
    Foam::fvMesh& mesh = meshPtr();
    Foam::Info << Foam::endl;
    // è§ä¸Šä¸€å°èŠ‚çš„è§£é‡Š
    

    Info<< "Mesh directory: " << mesh.meshDir() << endl; // methods from polyMesh
	// è¾“å‡ºmeshå­˜æ”¾çš„æ–‡ä»¶å¤¹è·¯å¾„
	
    const pointField& p = mesh.points(); // meshå¯¹è±¡é‡Œä¿å­˜çš„ç‚¹
    Info<< "Number of points: " << p.size() << endl;
    for (int i=0; i<3; ++i) // æ˜¾ç¤ºå‰3ä¸ªç‚¹
    {
        Info<< "("
            << setf(ios_base::scientific)
            << setw(15)
            << p[i][0]; // ç¬¬iç‚¹çš„åæ ‡åˆ†é‡1
        Info<< ", "
            << setf(ios_base::scientific)
            << setw(15)
            << p[i][1]; // ç¬¬iç‚¹çš„åæ ‡åˆ†é‡2
        Info<< ", "
            << setf(ios_base::scientific)
            << setw(15)
            << p[i][2] // ç¬¬iç‚¹çš„åæ ‡åˆ†é‡3
            << ")" << endl;
    }

    const faceList& f = mesh.faces(); // meshå¯¹è±¡é‡Œçš„é¢
    Info<< "Number of faces: " << f.size() << endl;
    forAll(f,i) // OpenFOAMæä¾›çš„éå†æ–¹æ³•
    {
        Info<< "("
            << setw(6) << f[i][0] // ç»„æˆç¬¬ié¢çš„ç¬¬1ä¸ªç‚¹çš„åºå·
            << setw(6) << f[i][1] // ç»„æˆç¬¬ié¢çš„ç¬¬2ä¸ªç‚¹çš„åºå·
            << setw(6) << f[i][2] // ç»„æˆç¬¬ié¢çš„ç¬¬3ä¸ªç‚¹çš„åºå·
            << setw(6) << f[i][3] // ç»„æˆç¬¬ié¢çš„ç¬¬4ä¸ªç‚¹çš„åºå·
            << ")" << endl;
    }
    // å¯ä»¥æ‰“å¼€ debug_case/constant/polyMesh/faces æ¯”è¾ƒ

    const labelList& fOwner = mesh.faceOwner();
    Info<< "Number of face owner: " << fOwner.size() << endl;
    forAll(fOwner,i)
    {
        Info<< setw(6) << fOwner[i] << endl;
    }
    // è¾“å‡ºè‡ªç„¶åˆ—è¡¨åºå·çš„é¢çš„ownerçš„å•å…ƒåºå·
	// ä¾‹å¦‚è¾“å‡º
	// 0                    // 0å·é¢çš„owneræ˜¯å•å…ƒ0
	// 0                    // 1å·é¢çš„owneræ˜¯å•å…ƒ0
	// 1                    // 2å·é¢çš„owneræ˜¯å•å…ƒ1
	// 2                    // 3å·é¢çš„owneræ˜¯å•å…ƒ2
	// ...
	// ä»¥æ­¤ç±»æ¨

    const labelList& fNeigh = mesh.faceNeighbour();
    Info<< "Number of face neighbour: " << fNeigh.size() << endl;
    forAll(fNeigh,i)
    {
        Info<< setw(6) << fNeigh[i] << endl;
    }
    // è¾“å‡ºè‡ªç„¶åˆ—è¡¨åºå·çš„é¢çš„neighbourçš„å•å…ƒåºå·
    // ä¾‹å¦‚
    // 1                   // 0å·é¢çš„neighbouræ˜¯å•å…ƒ1
    // 2                   // 1å·é¢çš„neighbouræ˜¯å•å…ƒ2
    // 3                   // 2å·é¢çš„neighbouræ˜¯å•å…ƒ3
    // 3                   // 3å·é¢çš„neighbouræ˜¯å•å…ƒ3
    // å…¶ä»–çš„é¢ä¸æ˜¯ä»»ä½•å•å…ƒçš„neighbour

    const polyBoundaryMesh& bm = mesh.boundaryMesh();
    Info<< "Number of boundary mesh: " << bm.size() << endl;
    forAll(bm,i)
    {
        Info<< "Boundary name: " << bm[i].name()
            << "\tBoundary type: " << bm[i].type()
            << endl;
    }
    // è¾“å‡ºè®¾ç½®çš„è¾¹ç•Œ


    Info<< nl << endl;
    
    Info<< "Bounding box: " << mesh.bounds() << endl;
    Info<< "Mesh volume: " << sum(mesh.V()).value() << endl;

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    Info<< nl;
    runTime.printExecutionTime(Info);

    Info<< "End\n" << endl;

    return 0;
}


// ************************************************************************* //

```

ä¸ºäº†æ–¹ä¾¿ç»“æœæ˜¾ç¤ºï¼Œä¿®æ”¹è°ƒè¯•ç®—ä¾‹ `debug_case/system/blockMeshDict` ä¸­è®¾ç½®çš„ç½‘æ ¼åˆ’åˆ†æ•°é‡

```
...
blocks
(
    hex (0 1 2 3 4 5 6 7) (2 2 1) simpleGrading (1 1 1)
);
...
```

### ç¼–è¯‘è¿è¡Œ

ç»“æœå¦‚ä¸‹

```
Create time

Default region: region0
Mesh sudirectory: polyMesh
Create mesh for time = 0

Mesh directory: "polyMesh"
Number of points: 18
(   0.000000e+00,    0.000000e+00,    0.000000e+00)
(   5.000000e-02,    0.000000e+00,    0.000000e+00)
(   1.000000e-01,    0.000000e+00,    0.000000e+00)
Number of faces: 20
(     1     4    13    10)
(     3    12    13     4)
(     4    13    14     5)
(     4     7    16    13)
(     6    15    16     7)
(     7    16    17     8)
(     0     9    12     3)
(     3    12    15     6)
(     2     5    14    11)
(     5     8    17    14)
(     0     1    10     9)
(     1     2    11    10)
(     0     3     4     1)
(     3     6     7     4)
(     1     4     5     2)
(     4     7     8     5)
(     9    10    13    12)
(    12    13    16    15)
(    10    11    14    13)
(    13    14    17    16)
Number of face owner: 20
     0
     0
     1
     2
     2
     3
     0
     2
     1
     3
     0
     1
     0
     2
     1
     3
     0
     2
     1
     3
Number of face neighbour: 4
     1
     2
     3
     3
Number of boundary mesh: 3
Boundary name: movingWall	Boundary type: wall
Boundary name: fixedWalls	Boundary type: wall
Boundary name: frontAndBack	Boundary type: empty


Bounding box: (0.000000e+00 0.000000e+00 0.000000e+00) (1.000000e-01 1.000000e-01 1.000000e-02)
Mesh volume: 1.000000e-04

ExecutionTime = 0.000000e+00 s  ClockTime = 0.000000e+00 s

End


```


## ç½‘æ ¼ç±»ä½¿ç”¨ç¤ºä¾‹

è®©æˆ‘ä»¬å°è¯•ä½¿ç”¨æ›´å¤šçš„ç½‘æ ¼ç±»æ–¹æ³•ï¼ˆæˆå‘˜å‡½æ•°ï¼‰ã€‚

### åº”ç”¨å‡†å¤‡

```
// terminal
foamNewApp 04_02_mesh
cd 04_02_mesh
cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity/cavity debug_case
code .
```

### è„šæœ¬å’Œè¯´æ˜

ä½¿ç”¨ä¸ŠèŠ‚ç›¸åŒè„šæœ¬å†…å®¹å³å¯ï¼Œç•¥


### ä¸»æºç 

ä¸»æºç å¦‚ä¸‹

```cpp
#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"

    #include "createMesh.H"

    Info<< "Time                    : " << runTime.timeName() << nl
        << "Number of mesh cells    : " << mesh.C().size() << nl
        << "Number of internal faces: " << mesh.Cf().size() << nl
        << endl;

    for (label cellI=0; cellI<mesh.C().size(); ++cellI) // C++åŸç”Ÿæ–¹å¼éå†
    {
        if (cellI%100 == 0)
        {
            Info<< "Cell " << cellI 
                << " with center at " << mesh.C()[cellI] // è¿”å›å•å…ƒä¸­å¿ƒåæ ‡
                << endl;
        }
    }
    Info<< nl << endl;
    

    forAll(mesh.owner(),faceI) // OpenFOAMæ–¹å¼éå†
    {
        if (faceI%200 == 0)
        {
            Info<< "Internal face " << faceI
                << " with center at " << mesh.Cf()[faceI] // è¿”å›é¢ä¸­å¿ƒåæ ‡
                << " with owner cell " << mesh.owner()[faceI] // è¿”å›å•å…ƒåºå·
                << " and neighbour cell " << mesh.neighbour()[faceI] // è¿”å›å•å…ƒåºå·
                << endl;
        }
    }
    Info<< nl << endl;

    forAll(mesh.boundaryMesh(), patchI)
    {
        Info<< "Patch " << patchI
            << " is " << mesh.boundary()[patchI].name() // è¿”å›è¾¹ç•Œåç§°
            << " with " << mesh.boundary()[patchI].Cf().size() << " faces. "
            // è¿”å›è¾¹ç•Œå•å…ƒé¢çš„æ•°é‡
            << "Start from face " << mesh.boundary()[patchI].start()
            // è¿”å›è¾¹ç•Œå…¶å®é¢åºå·
            << endl;
    }
    Info<< nl << endl;

    label nIndex(0); // è‡ªå·±è®¾ç½®ä¸€ä¸ªåºå·
    forAll(mesh.boundaryMesh(), patchI) // è¾¹ç•Œä¸­éå†
    {
        Info<< "Patch " << patchI << nl
            << "\tits face " << nIndex
            << " adjacent to cell " << mesh.boundary()[patchI].patch().faceCells()[nIndex] << nl
            // è¿”å›ç›¸é‚»å•å…ƒåºå·
            << "\tits normal vector " << mesh.boundary()[patchI].Sf()[nIndex] << nl
            // è¿”å›è¾¹ç•Œä¸­é¢çš„é¢æ³•å‘é‡
            << "\tits surface area " << mag(mesh.boundary()[patchI].Sf()[nIndex]) << nl
            // è¿”å›é¢å¤§å°
            << endl;
    }
    Info<< nl << endl;


    const faceList& fcs = mesh.faces();
    const pointField& pts = mesh.points(); // ä¹Ÿå¯ä»¥ä½¿ç”¨ List<point>& ç±»å‹
    const List<point>& cents = mesh.faceCentres(); // æ‰€æœ‰é¢å¿ƒ

    forAll(fcs,faceI) // åœ¨æ‰€æœ‰é¢ä¸­éå†
    {
        if (faceI%200 == 0)
        {
            if (faceI < mesh.Cf().size()) // å¦‚æœæ˜¯å†…éƒ¨é¢
            {
                Info<< "Internal face ";
            } else // å¦åˆ™æ˜¯è¾¹ç•Œé¢
            {
                forAll(mesh.boundary(),patchI)
                {
                    if ( (mesh.boundary()[patchI].start() <= faceI) &&
                        (faceI < mesh.boundary()[patchI].start() + 
                        mesh.boundary()[patchI].Cf().size()))
                        // å¦‚æœåœ¨æ­¤è¾¹ç•Œå†…
                    {
                        Info<< "Face on patch " << patchI << ", faceI ";
                        break;
                    }
                }
            }
            Info<< faceI << " with centre at " << cents[faceI] // è¿”å›é¢å¿ƒåæ ‡
                << " has " << fcs[faceI].size() << " vertices: "; // è¿”å›é¢èŠ‚ç‚¹æ•°é‡
            forAll(fcs[faceI],vertexI) // åœ¨è¯¥é¢éå†
            {
                Info<< " " << pts[fcs[faceI][vertexI]]; // è¾“å‡ºèŠ‚ç‚¹åæ ‡
            }
            Info<< endl;
        }
    }
    Info<< nl << endl;

	// ä¸€èˆ¬æ¥è¯´ï¼Œ empty çš„è¾¹ç•Œéœ€è¦ç‰¹åˆ«æ³¨æ„ï¼Œæœ‰æ—¶å€™éœ€è¦ä¸“é—¨å¤„ç†
	// éœ€è¦æ‰¾å‡º empty çš„è¾¹ç•Œçš„é¢
    forAll(mesh.boundaryMesh(),patchI) // éå†ç»„æˆè¾¹ç•Œçš„æ‰€æœ‰é¢
    {
        const polyPatch& pp = mesh.boundaryMesh()[patchI];
        if (isA<emptyPolyPatch>(pp)) // å¦‚æœé¢æ˜¯emptyçš„
        {
            Info<< "Patch " << patchI
                << ": " << mesh.boundary()[patchI].name() // è¿”å›è¾¹ç•Œåç§°
                << " is empty."
                << endl;
        }
    }
    Info<< nl << endl;

    word patchName("movingWall");
    label patchID = mesh.boundaryMesh().findPatchID(patchName);
    // æ‰¾åˆ°ç¬¦åˆåç§°çš„è¾¹ç•Œé¢
    Info<< "Retrived patch " << patchName
        << " at index " << patchID
        << " using its name only."
        << endl;
    Info<< nl << endl;
	

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    Info<< nl;
    runTime.printExecutionTime(Info);

    Info<< "End\n" << endl;

    return 0;
}


// ************************************************************************* //

```

### ç¼–è¯‘è¿è¡Œ

ç»“æœå¦‚ä¸‹

```
Create time

Create mesh for time = 0

Time                    : 0
Number of mesh cells    : 400
Number of internal faces: 760

Cell 0 with center at (0.0025 0.0025 0.005)
Cell 100 with center at (0.0025 0.0275 0.005)
Cell 200 with center at (0.0025 0.0525 0.005)
Cell 300 with center at (0.0025 0.0775 0.005)


Internal face 0 with center at (0.005 0.0025 0.005) with owner cell 0 and neighbour cell 1
Internal face 200 with center at (0.0125 0.03 0.005) with owner cell 102 and neighbour cell 122
Internal face 400 with center at (0.03 0.0525 0.005) with owner cell 205 and neighbour cell 206
Internal face 600 with center at (0.0375 0.08 0.005) with owner cell 307 and neighbour cell 327


Patch 0 is movingWall with 20 faces. Start from face 760
Patch 1 is fixedWalls with 60 faces. Start from face 780
Patch 2 is frontAndBack with 0 faces. Start from face 840


Patch 0
	its face 0 adjacent to cell 380
	its normal vector (0 5e-05 0)
	its surface area 5e-05

Patch 1
	its face 0 adjacent to cell 0
	its normal vector (-5e-05 0 0)
	its surface area 5e-05

Patch 2
	its face 0 adjacent to cell 0
	its normal vector (0 0 -2.5e-05)
	its surface area 2.5e-05



Internal face 0 with centre at (0.005 0.0025 0.005) has 4 vertices:  (0.005 0 0) (0.005 0.005 0) (0.005 0.005 0.01) (0.005 0 0.01)
Internal face 200 with centre at (0.0125 0.03 0.005) has 4 vertices:  (0.01 0.03 0) (0.01 0.03 0.01) (0.015 0.03 0.01) (0.015 0.03 0)
Internal face 400 with centre at (0.03 0.0525 0.005) has 4 vertices:  (0.03 0.05 0) (0.03 0.055 0) (0.03 0.055 0.01) (0.03 0.05 0.01)
Internal face 600 with centre at (0.0375 0.08 0.005) has 4 vertices:  (0.035 0.08 0) (0.035 0.08 0.01) (0.04 0.08 0.01) (0.04 0.08 0)
Face on patch 1, faceI 800 with centre at (0.1 0.0025 0.005) has 4 vertices:  (0.1 0 0) (0.1 0.005 0) (0.1 0.005 0.01) (0.1 0 0.01)
1000 with centre at (0.0425 0.0025 0) has 4 vertices:  (0.04 0 0) (0.04 0.005 0) (0.045 0.005 0) (0.045 0 0)
1200 with centre at (0.0925 0.0025 0) has 4 vertices:  (0.09 0 0) (0.09 0.005 0) (0.095 0.005 0) (0.095 0 0)
1400 with centre at (0.0425 0.0025 0.01) has 4 vertices:  (0.04 0 0.01) (0.045 0 0.01) (0.045 0.005 0.01) (0.04 0.005 0.01)
1600 with centre at (0.0925 0.0025 0.01) has 4 vertices:  (0.09 0 0.01) (0.095 0 0.01) (0.095 0.005 0.01) (0.09 0.005 0.01)


Patch 2: frontAndBack is empty.


Retrived patch movingWall at index 0 using its name only.



ExecutionTime = 0 s  ClockTime = 0 s

End


```

## è®¡ç®—ç½‘æ ¼ä½“ç§¯æ¯”

æˆ‘ä»¬åŸºäºå‰é¢ç½‘æ ¼æ–¹æ³•çš„è®¨è®ºæ¥å°è¯•ä¸€ä¸ªè®¡ç®—ç½‘æ ¼å‚æ•°çš„åº”ç”¨ï¼Œä¹Ÿè®¸ä»¥åä¼šç”¨åœ¨æ±‚è§£å™¨å¼€å‘ä¸Šã€‚

> ä»£ç æ¥è‡ª Tom Smith è®²ä¹‰ã€Šprogramming with OpenFOAMã€‹ï¼ˆè§æ–‡é¦–å‚è€ƒé“¾æ¥ï¼‰

### åº”ç”¨å‡†å¤‡

```
// terminal 
foamNewApp 04_03_mesh
cd 04_03_mesh
cp -r $FOAM_TUTORIALS/incompressible/simpleFoam/pitzDaily debug_case
```

### è„šæœ¬å’Œè¯´æ˜

ä»¥åéç‰¹åˆ«è¯´æ˜ï¼Œä¸å†èµ˜è¿°ã€‚

### ä¸»æºç 

ä¸»æºç å¦‚ä¸‹

```cpp
#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"

    #include "createMesh.H"

    const scalar c = mesh.C().size();
    Info<< "Number of cells = " << c << endl;
    // ç½‘æ ¼å•å…ƒæ•°é‡

    const labelListList& neighbour = mesh.cellCells();
    // è¿”å›é‚»å•å…ƒä¸ºæ–°åˆ—è¡¨

    List<scalar> ratios(0); // å£°æ˜ä¸€ä¸ªscalaråˆ—è¡¨ä¸”å…¨åˆå§‹åŒ–ä¸º0
    scalar volumeRatio = 0;

    forAll (neighbour, cellI) // éå†é‚»å•å…ƒï¼Œå…¶å®å°±æ˜¯æ‰€æœ‰å•å…ƒ
    {
        List<label> n = neighbour[cellI];
        // å¯¹æ¯ä¸ªå•å…ƒï¼Œè·å¾—å®ƒçš„é‚»å•å…ƒåˆ°åˆ—è¡¨ n

        const scalar cellVolume = mesh.V()[cellI];
        // æœ¬å•å…ƒä½“ç§¯

        forAll (n, i) // å¯¹äºæŸä¸ªæœ¬å•å…ƒï¼Œéå†å®ƒçš„é‚»å•å…ƒ
        {
            label neighbourIndex = n[i];
            scalar neighbourVolume = mesh.V()[neighbourIndex];
            // é‚»å•å…ƒä½“ç§¯

            if (neighbourVolume >= cellVolume) // ä½“ç§¯æ¯”å¤§äº 1 çš„æƒ…å†µ
            {
                volumeRatio = neighbourVolume / cellVolume;
                ratios.append(volumeRatio);
                // ä½“ç§¯æ¯”å­˜å…¥ ratios åˆ—è¡¨
                // æ–¹ä¾¿ä½†æ˜¯æ•ˆç‡ä½
            }
        }
    }

    Info<< "Maximum volume ratio = " << max(ratios) << endl;
    // æœ€å¤§ä½“ç§¯æ¯”


    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    Info<< nl;
    runTime.printExecutionTime(Info);

    Info<< "End\n" << endl;

    return 0;
}
```



ç¼–è¯‘è¿è¡Œï¼Œç»“æœä¸º

```
Create time

Create mesh for time = 0

Number of cells = 12225
Maximum volume ratio = 1.49908

ExecutionTime = 0.13 s  ClockTime = 0 s

End
```

### ä»£ç æ”¹è¿›

`List` ç±»çš„ `append` æ–¹æ³•è™½ç„¶æ–¹ä¾¿ï¼Œä½†æ˜¯æ•ˆç‡å¾ˆä½ï¼Œå› ä¸ºæ¯ä¸€æ¬¡å‘ `List` æ·»åŠ æ•°æ®çš„æ—¶å€™ï¼Œéƒ½è¦åˆ›å»ºä¸€ä¸ª n+1 å¤§å°çš„æ–° `List` ï¼Œå°†è€æ•°æ®æ‹·è´è¿‡å»ï¼Œå†åŠ å…¥æ–°æ•°æ®ã€‚åœ¨æ•°æ®é‡å¾ˆå¤§çš„æ—¶å€™ï¼Œæ¯æ¬¡æ·»åŠ æ–°æ•°æ®éƒ½æœ‰æ–°å»ºå†å¤åˆ¶çš„è¿‡ç¨‹ï¼Œæ•ˆç‡éå¸¸ä½ã€‚

æˆ‘ä»¬è€ƒè™‘åˆ°å¯¹äºè¦å¤„ç†çš„ç½‘æ ¼ï¼Œå› ä¸ºç½‘æ ¼ç¡®å®šï¼Œæ‰€ä»¥è¦è®¡ç®—çš„ä½“ç§¯æ¯”æ€»é‡ä¹Ÿæ˜¯ç¡®å®šçš„ã€‚å¯ä»¥æå‰å£°æ˜ä¸€ä¸ªå›ºå®šå¤§å°çš„ `List`ï¼Œåˆ†é…å¥½å†…å­˜ï¼Œåç»­åªéœ€è¦å‘å…¶æ·»åŠ æ•°æ®å°±è¡Œã€‚

æ”¹è¿›åä¸»æºç å¦‚ä¸‹

```cpp
#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"

    #include "createMesh.H"

    const scalar c = mesh.C().size();
    Info<< "Number of cells = " << c << endl;

    const labelListList& neighbour = mesh.cellCells();

	/*
	* ä»£ç æ”¹è¿›å¦‚ä¸‹ 
	*/
    label len = mesh.Cf().size(); // éœ€è¦çš„ ratio çš„ List å¤§å°
    scalar initial = 0;
    List<scalar> ratios(len, initial); // åˆ›å»ºå›ºå®šå¤§å°çš„ List 
    label counter = 0; // ratios çš„åºå·
    scalar volumeRatio = 0;

    forAll (neighbour, cellI) // éå†é‚»å•å…ƒ
    {
        List<label> n = neighbour[cellI];

        const scalar cellVolume = mesh.V()[cellI];

        forAll (n, i)
        {
            label neighbourIndex = n[i];
            scalar neighbourVolume = mesh.V()[neighbourIndex];

            if (neighbourVolume >= cellVolume)
            {
                volumeRatio = neighbourVolume / cellVolume;
                ratios[counter] = volumeRatio; // å­˜å‚¨ä½“ç§¯æ¯”
                counter += 1;
            }
        }
    }

    Info<< "Maximum volume ratio = " << max(ratios) << endl;

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    Info<< nl;
    runTime.printExecutionTime(Info);

    Info<< "End\n" << endl;

    return 0;
}
```

ç¼–è¯‘è¿è¡Œç»“æœå¦‚ä¸‹

```
Create time

Create mesh for time = 0

Number of cells = 12225
Maximum volume ratio = 1.49908

ExecutionTime = 0.06 s  ClockTime = 0 s

End
```

å¯ä»¥å¾ˆæ˜æ˜¾çœ‹åˆ°è¿è¡Œæ—¶é—´ä» 0.13s å‡å°‘åˆ°äº† 0.06sï¼Œæ•ˆç‡å¤§å¤§æé«˜ã€‚

### ä»£ç å†æ”¹è¿›

å¦‚æœæˆ‘ä»¬åªæ˜¯è¦è·å¾—æœ€å¤§ä½“ç§¯æ¯”ï¼Œé‚£ä¹ˆå…¶å®æˆ‘ä»¬ä¸éœ€è¦ä¿å­˜æ‰€æœ‰çš„ä½“ç§¯æ¯”ï¼Œä¿å­˜ä½“ç§¯æ¯”çš„æœ€å¤§å€¼å°±å¤Ÿäº†ã€‚

ä¸»æºç å¦‚ä¸‹

```cpp
#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"

    #include "createMesh.H"

    const scalar c = mesh.C().size();
    Info<< "Number of cells = " << c << endl;

    const labelListList& neighbour = mesh.cellCells();

	/*
	* ä»£ç æ”¹è¿›å¦‚ä¸‹ 
	*/
    scalar volumeRatio = 0.0;
    scalar currentRatio = 0.0;

    forAll (neighbour, cellI)
    {
        List<label> n = neighbour[cellI];

        const scalar cellVolume = mesh.V()[cellI];

        forAll (n, i)
        {
            label neighbourIndex = n[i];
            scalar neighbourVolume = mesh.V()[neighbourIndex];

            if (neighbourVolume >= cellVolume)
            {
                volumeRatio = neighbourVolume / cellVolume;

                if (volumeRatio > currentRatio) // åªå­˜å‚¨æœ€å¤§ä½“ç§¯æ¯”
                {
                    currentRatio = volumeRatio;
                }
            }
        }
    }

    Info<< "Maximum volume ratio = " << currentRatio << endl;

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    Info<< nl;
    runTime.printExecutionTime(Info);

    Info<< "End\n" << endl;

    return 0;
}
```

ç¼–è¯‘è¿è¡Œç»“æœå¦‚ä¸‹

```
Create time

Create mesh for time = 0

Number of cells = 12225
Maximum volume ratio = 1.49908

ExecutionTime = 0.05 s  ClockTime = 0 s

End
```

å¯ä»¥çœ‹åˆ°è¿è¡Œæ—¶é—´è¿›ä¸€æ­¥å‡å°‘ï¼Œæ•ˆç‡åˆæé«˜äº†ã€‚

### ä»£ç æœ€ç»ˆç‰ˆ

ä»…è·å¾—ä½“ç§¯æ¯”è¿˜ä¸å¤Ÿï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›çŸ¥é“æµ‹è¯•ç®—ä¾‹çš„ç½‘æ ¼æœ‰å¤šå°‘è¶…è¿‡äº†æŒ‡å®šçš„ä½“ç§¯æ¯”å‡†åˆ™ã€‚

æˆ‘ä»¬é€šè¿‡ OpenFOAM çš„å­—å…¸æ¥æ¥å…¥ä½“ç§¯æ¯”å‡†æµ‹è¿™ä¸€å‚æ•°ã€‚

ä¸ºæµ‹è¯•ç®—ä¾‹æä¾›å­—å…¸ `/userApp/debug_case/system/volumeRatioDict` ï¼Œå†…å®¹å¦‚ä¸‹

> æˆ‘ä»¬çº¦å®š
> - `*Properties` æ–‡ä»¶æ”¾åœ¨ `/userApp/constant` æ–‡ä»¶å¤¹ä¸‹
> - `*Dict` æ–‡ä»¶æ”¾åœ¨ `/userApp/system` æ–‡ä»¶å¤¹ä¸‹

```cpp
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      blockMeshDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

maxRatio 1.2;
```

ä¸»æºç å¦‚ä¸‹

```cpp
#include "fvCFD.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

int main(int argc, char *argv[])
{
    #include "setRootCase.H"
    #include "createTime.H"

    #include "createMesh.H"

    IOdictionary volumeRatioDict // å»ºç«‹å­—å…¸å¯¹è±¡
    (
        IOobject
        (
            "volumeRatioDict", // æ–‡ä»¶åç§°
            runTime.system(), // æ–‡ä»¶è·¯å¾„
            mesh, // åŸºäº mesh æ„é€ 
            IOobject::MUST_READ, // å¿…è¯»
            IOobject::NO_WRITE // åªè¯»ä¸å†™
        )
    );

    const scalar c = mesh.C().size();
    Info<< "Number of cells = " << c << endl;

    const labelListList& neighbour = mesh.cellCells();

    scalar volumeRatio = 0.0;
    scalar currentRatio = 0.0;

    label nFail = 0; // ç»Ÿè®¡è¶…å‡ºå‡†æµ‹çš„æ•°é‡

    scalar maxRatio(readScalar(volumeRatioDict.lookup("maxRatio")));
	// ä»å­—å…¸è¯»å…¥

    forAll (neighbour, cellI)
    {
        List<label> n = neighbour[cellI];

        const scalar cellVolume = mesh.V()[cellI];

        forAll (n, i)
        {
            label neighbourIndex = n[i];
            scalar neighbourVolume = mesh.V()[neighbourIndex];

            if (neighbourVolume >= cellVolume)
            {
                volumeRatio = neighbourVolume / cellVolume;

                if (volumeRatio > currentRatio)
                {
                    currentRatio = volumeRatio;
                }

                if (volumeRatio > maxRatio) // ç»Ÿè®¡è¶…å‡ºå‡†æµ‹çš„æ•°é‡
                {
                    nFail += 1;
                }
            }
        }
    }

    Info<< "Maximum volume ratio = " << currentRatio << nl
        << "Number of cell volume ratios exceeding " << maxRatio
        << " = " << nFail << nl
        << endl;

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    Info<< nl;
    runTime.printExecutionTime(Info);

    Info<< "End\n" << endl;

    return 0;
}

```

ç¼–è¯‘è¿è¡Œï¼Œç»“æœå¦‚ä¸‹

```
Create time

Create mesh for time = 0

Number of cells = 12225
Maximum volume ratio = 1.49908
Number of cell volume ratios exceeding 1.2 = 532


ExecutionTime = 0.06 s  ClockTime = 1 s

End
```


## å°ç»“

é€šè¿‡å‰é¢çš„å‡ ç¯‡æ–‡ç« ï¼ŒOpenFOAM åº”ç”¨çš„å¸¸è§å¤´æ–‡ä»¶ `setRootCase.H` ï¼Œ`createTime.H` å’Œ `createMesh.H` å·²ç»å°½å¯èƒ½åœ¨ä¸è¿‡åº¦æ·±å…¥çš„æƒ…å†µä¸‹è¿›è¡Œäº†è®¨è®ºã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬ä¹Ÿå°è¯•è®¨è®ºäº†ä¸€ä¸ªåŸºäºç¦»æ•£ç½‘æ ¼çš„å®Œæ•´åº”ç”¨ï¼Œä¸æ–­æ”¹è¿›çš„è¿‡ç¨‹å¯¹æˆ‘ä»¬ä»¥åå¼€å‘è‡ªå·±çš„æ±‚è§£å™¨ä¹Ÿæœ‰ä¸€äº›å¯å‘ã€‚

é™¤äº†ä¸»å‡½å‚æ•°ã€æ—¶é—´å’Œç¦»æ•£ç½‘æ ¼ï¼Œæˆ‘ä»¬æ€ä¹ˆåˆ›å»ºä»¥åŠè®¡ç®—æ§åˆ¶æ–¹ç¨‹æ–¹ç¨‹ä¸­çš„ç‰©ç†é‡å‘¢ï¼Ÿ